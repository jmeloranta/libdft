\documentclass[12pt,letterpaper]{report}
\usepackage[letterpaper,hcentering,vcentering,left=1in,top=2.45cm,right=1in,bott
om=2.45cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage{url}
\usepackage{longtable}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\author{Jussi Eloranta}
\title{libdft manual}
\begin{document}

\maketitle

\chapter{Prerequisites}

\section{Introduction}

Libdft provides implementation of Orsay-Trento (OT), Gross-Pitaevskii (and other 
similar) density functional for modeling superfluid $^4$He. It is built on top 
of libgrid library, which allows parallel execution on both shared memory 
CPU-based systems as well as GPUs. As libdft is a set of library functions,
each user application consists of a main C (or C++) program that makes
function calls to libdft (and possibly libgrid). 
Libdft was written by Lauri Lehtovaara, David Mateo, and Jussi Eloranta, and 
can be freely distributed according to GNU GENERAL PUBLIC LICENSE Version 3 
(see doc/GPL.txt). This project was partially supported by National Science 
Foundation grants: CHE-0949057, CHE-1262306 and DMR-1205734.

\section{Brief description of Orsay-Trento}

The following references provide the necessary background to Orsay-Trento functional(s):
\begin{itemize}
\item Original Orsay-Trento functional for $^4$He at 0 K: Phys. Rev. B 52, 1192 (1995).
\item Extension of Orsay-Trento functional to non-zero temperatures: Phys. Rev. B. 62, 17035 (2000).
\item High-density correction to Orsay-Trento: Phys. Rev. B 72, 214522 (2005).
\item Implementation of Orsay-Trento: J. Comput. Phys. 194, 78 (2004) and J. Comput. Phys. 221, 148 (2007).
\item Review article on Orsay-Trento and applications (also high-density correction to backflow): Int. Rev. Phys. Chem. 36, 621 (2017).
\end{itemize}

% OT energy density here

% OT functional derivative here

% Note that Dupont-Roc and Gross-Pitaevskii can also be used.

\section{Installation}

Installation of libdft requires the following packages:
\begin{itemize}
\item git (a free and open source distributed version control system)
\item GNU C compiler with OpenMP support (gcc)
\item FFTW 3.x (Fast Fourier Transform package)
\item libgrid (grid library)
\end{itemize}
To install these packages on Fedora linux, use (\# implies execution with root privileges): 
\begin{verbatim}
# dnf install git gcc fftw-*
\end{verbatim}
Furthermore, libgrid must be installed before compiling libdft.

To copy the current version of libdft to subdirectory libgrid, issue 
(\% implies execution with normal user privileges):
\begin{verbatim}
% git clone https://github.com/jmeloranta/libdft.git
\end{verbatim}
To compile libdft, change to libdft source code directory and run make:
\begin{verbatim}
% cd libdft/src
% make -j
\end{verbatim}
No changes to any of the compilation options are required as it will 
automatically use the same flags as the currently installed libgrid.
Provided that the compilation completed without errors, install the library 
(as root):
\begin{verbatim}
# make install
\end{verbatim}

\chapter{Programming interface}

\section{Accessing the library routines}

To access libdft functions in C program, the following header files should be 
included:
\begin{verbatim}
#include <dft/dft.h>
#include <dft/ot.h>
\end{verbatim}

To compile and link a program using libdft and libgrid, it is most convenient 
to construct a makefile (note that the \$(CC) line has TAB as the first 
character):
\begin{verbatim}
include /usr/include/dft/make.conf

test: test.o
    $(CC) $(CFLAGS) -o test test.o $(LDFLAGS)

test.o: test.c
\end{verbatim}
This will compile the program specified in test.c and link the appropriate 
libraries automatically. Both CFLAGS and LDFLAGS are obtained automatically. Note that if you changed the ROOT directory when installing libgrid, you need to replace /usr above with that directory.

\section{Data types}

The libdft header file ot.h defines the OT structure (data type dft\_ot\_functional) that contains the description of the functional to be used:

\begin{verbatim}
typedef struct dft_ot_functional_struct { /* All values in atomic units */
  INT model;              /* Functional DFT_OT_* (Orsay-Trento), DFT_DR (Dupont-Roc) */        
                          /* DFT_GP (Gross-Pitaevskii) */
  REAL b;                 /* Lennard-Jones integral value for bulk (not used in */
                          /* functional) */
  REAL c2;                /* Orsay-Trento short-range correlation parameter c_2 */
                          /* (2nd power) */
  REAL c2_exp;            /* Exponent for the above (= 2 for OT) */
  REAL c3;                /* Orsay-Trento short-range correlation parameter c_3 */
                          /* (3rd power) */
  REAL c3_exp;            /* Exponent for the above (= 3 for OT) */
  REAL c4;                /* Thermal Orsay-Trento parameter c_4 (Ancilotto et al.) */
  REAL rho_0s;            /* Orsay-Trento kinetic energy correlation parameter */
                          /* \rho_{0s} */
  REAL alpha_s;           /* Orsay-Trento kinetic energy correlation parameter */
                          /* \alpha_s */
  REAL l_g;               /* Width of gaussian F used in kinetic correlation */
  REAL mass;              /* ^4He mass */
  REAL rho0;              /* Uniform bulk liquid density at saturated vapor pressure */
  REAL temp;              /* Temperature (Kelvin) */
  dft_common_lj lj_params;/* Lennard-Jones parameters */
  dft_ot_bf bf_params;    /* Backflow functional parameters */
  rgrid *lennard_jones;   /* Grid holding Fourier transformed effective Lennard-Jones*/
                          /* function */
  rgrid *spherical_avg;   /* Grid holding Fourier transformed spherical average */
                          /* function */
  rgrid *gaussian_tf;     /* Grid holding Fourier transformed gaussian F */
                          /* (kinetic correlation) */ 
  rgrid *gaussian_x_tf;   /* Grid holding Fourier transformed derivative of */
                          /* gaussian F (dF/dx; kinetic correlation) */ 
  rgrid *gaussian_y_tf;   /* Grid holding Fourier transformed derivative of */
                          /* gaussian F (dF/dy; kinetic correlation) */ 
  rgrid *gaussian_z_tf;   /* Grid holding Fourier transformed derivative of */
                          /* gaussian F (dF/dz; kinetic correlation) */ 
  rgrid *backflow_pot;    /* Grid holding Fourier transformed bacflow function (V_j) */
  REAL beta;              /* High density correction parameter \beta */
  REAL rhom;              /* High density correction parameter \rho_m */
  REAL C;                 /* High density correction parameter C */
  REAL mu0;               /* Determines Gross-Pitaevskii contact strength: */
                          /* \mu_0 / \rho_0 */
  REAL xi;                /* High density correction parameter for backflow \xi */
  REAL rhobf;             /* High density correction parameter for backflow \rho_{bf}*/
  REAL veloc_cutoff;      /* Velocity cutoff to be used for evaluating velocity field*/
                          /* (affects, e.g., backflow) */
  REAL div_epsilon;       /* Epsilon to use when dividing by density */
                          /* (affects, e.g., backflow) */
  rgrid *workspace1;      /* Workspace 1 (these may be NULL if not allocated) */
  rgrid *workspace2;      /* Workspace 2 */
  rgrid *workspace3;      /* Workspace 3 */
  rgrid *workspace4;      /* Workspace 4 */
  rgrid *workspace5;      /* Workspace 5 */
  rgrid *workspace6;      /* Workspace 6 */
  rgrid *workspace7;      /* Workspace 7 */
  rgrid *workspace8;      /* Workspace 8 */
  rgrid *workspace9;      /* Workspace 9 */
  rgrid *density;         /* Liquid density */
} dft_ot_functional;
\end{verbatim}

\noindent
These fields are initialized by calling function dft\_ot\_alloc() (see below). The density and workspace grids are used during evaluation of the Orsay-Trento potential, but they may be used for other purposes outside dft\_ot\_potential(). At present the workspace allocation is as follows (density is used by all functionals):

\begin{tabular}{lll}
Functional name & libdft notation & Number of workspaces used\\
\cline{1-3}
Gross-Pitaevskii & DFT\_GP & Workspace 1\\
Plain Orsay-Trento & DFT\_OT\_PLAIN & Workspaces 1 - 3.\\
 & & Includes also thermal DFT (DFT\_OT\_T*).\\
O-T with KC & DFT\_OT\_KC & Workspaces 1 - 6.\\
O-T with BF & DFT\_OT\_BACKFLOW & Workspaces 1 - 9.\\
\end{tabular}

\noindent
The functionals listed in the above table are specified in the next section.

\section{Functionals and their modifiers}

The following functionals and their modifiers have been implemented in libdft:

\begin{longtable}{p{.33\textwidth} p{.4\textwidth} p{.33\textwidth}}
Functional & libdft notation for the functional & Class\\
\cline{1-3}
Plain Orsay-Trento & DFT\_PLAIN & Functional\\
Dupont-Roc & DFT\_DR & Functional\\
Gross-Pitaevskii & DFT\_GP & Functional\\
Thermal O-T at 0 K & DFT\_OT\_T0MK & Functional\\
Thermal O-T at 0.4 K & DFT\_OT\_T400MK & Functional\\
Thermal O-T at 0.6 K & DFT\_OT\_T600MK & Functional\\
Thermal O-T at 0.8 K & DFT\_OT\_T800MK & Functional\\
Thermal O-T at 1.2 K & DFT\_OT\_T1200MK & Functional\\
Thermal O-T at 1.4 K & DFT\_OT\_T1400MK & Functional\\
Thermal O-T at 1.6 K & DFT\_OT\_T1600MK & Functional\\
Thermal O-T at 1.8 K & DFT\_OT\_T1800MK & Functional\\
Thermal O-T at 2.0 K & DFT\_OT\_T2000MK & Functional\\
Thermal O-T at 2.1 K & DFT\_OT\_T2100MK & Functional\\
Thermal O-T at 2.2 K & DFT\_OT\_T2200MK & Functional\\
Thermal O-T at 2.4 K & DFT\_OT\_T2400MK & Functional\\
Thermal O-T at 2.6 K & DFT\_OT\_T2600MK & Functional\\
Thermal O-T at 2.8 K & DFT\_OT\_T2800MK & Functional\\
Thermal O-T at 3.0 K & DFT\_OT\_T3000MK & Functional\\
O-T high density correction1 & DFT\_OT\_HD & Modifier for DFT\_OT\_PLAIN\\
O-T high density correction2 & DFT\_OT\_HD2 & Modifier for DFT\_OT\_PLAIN\\
O-T backflow & DFT\_OT\_BACKFLOW & Modifier to include the backflow term in Orsay-Trento\\
O-T kinetic correlation & DFT\_OT\_KC & Modifier to include the kinetic energy correlation term in Orsay-Trento.\\ 
\end{longtable}
\noindent
The two high-density corrections (1 and 2) refer to two slightly different parametrizations of the penalty term. Invoking either of these two modifiers will also include the high-density correction to the backflow functional.

To apply a functional and the desired modifiers, use logical or. For example, to use the full Orsay-Trento, specify DFT\_OT\_PLAIN $|$ DFT\_OT\_KC $|$ DFT\_OT\_BACKFLOW. Here $|$ is the or operator in C (and operator would be \&).

Libdft include files also define the following useful constants:

\begin{tabular}{ll}
Name & Description\\
\cline{1-2}
DFT\_KB & Boltzmann constant in atomic units.\\
DFT\_HELIUM\_MASS & $^4$He atom mass.\\
DFT\_MIN\_SUBSTEPS & Minimum \# of steps for grid\_smooth\_map() function to be used.\\
DFT\_MAX\_SUBSTEPS & Maximum \# of steps for grid\_smooth\_map() function to be used.\\
\end{tabular}\\

\noindent
The latter two constants are often used when calling dft\_ot\_alloc(). Just like libgrid, libdft uses atomic units everywhere.

\chapter{Library functions}

Libdft provides only the routines that are specific to Orsay-Trento (Gross-Pitaevskii etc.) models. All common grid operations are handled by direct calls to libgrid. Each available library routine in libdft is described below.

\section{Allocating, using and freeing a functional}

\subsection{dft\_ot\_alloc() -- Allocate functional}

Allocate functional of specified type. This function must be called before attempting to evaluate the potential for functional. It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
INT model & Which DFT model to use. The available functionals are specified in the table (previous chapter; e.g., DFT\_OT\_PLAIN).\\
wf *wf & Wave function to be used with this functional. This specifies the grid etc. dimensions.\\
min\_substeps & Minimum number of substeps to be used in grid\_smooth\_map when mapping various model dependent functions onto grids. DFT\_MIN\_SUBSTEPS is a good choice.\\
max\_substeps & Maximum number of substeps to be used in grid\_smooth\_map when mapping various model dependent functions onto grids. DFT\_MAX\_SUBSTEPS is a good choice.\\
\end{longtable}
\noindent
This function returns a pointer to the allocated functional structure (dft\_ot\_functional *).

\subsection{dft\_ot\_potential() -- Evaluate non-linear potential for functional}

Calculate the non-linear potential grid for functional described by a given dft\_ot\_functional structure. The arguments to this function are:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
dft\_ot\_functional *otf & Functional structure provided by dft\_ot\_alloc().\\
cgrid *potential & Potential grid where the result will be added. Note that the potential will be added to this grid (i.e., may want to zero it first).\\
wf *wf & Wave function associated with the functional.\\                  
\end{longtable}
\noindent
This function does not return any value.

\subsection{dft\_ot\_free() -- Free functional structure and workspaces}

Free the given functional structure and the associated workspaces. It takes one argument that specifies the functional to be freed (dft\_ot\_functional *). Function has no return value.

\subsection{dft\_ot\_energy\_density() -- Calculate energy density for functional}

Evaluate the potential part to the energy density (kinetic part not included). The kinetic part should be calculated separately with grid\_wf\_kinetic\_energy(). The arguments are:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
dft\_ot\_functional *otf & Functional structure.\\
rgrid *energy\_density & Energy density grid.\\
\end{longtable}
\noindent
To get the total potential energy, integrate over energy\_density (e.g., rgrid\_integrate(energy\_density)). This function does not return any value.

\section{Bulk liquid routines}

The following routines apply to bulk liquid.

\subsection{dft\_ot\_bulk\_energy() -- Energy density of bulk liquid}

Calculate the energy density of uniform bulk liquid. This function takes the arguments as:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
dft\_ot\_functional *otf & Functional to be used.\\
REAL rho & Bulk liquid density.\\
\end{longtable}
\noindent
This function returns the bulk liquid energy density (i.e., energy / volume; REAL).

\subsection{dft\_ot\_bulk\_dEdRho() -- Calculate $dE/d\rho$ for bulk liquid}

Calculate derivative of energy with respect to density for uniform bulk liquid. At equilibrium, this is equal to the chemical potential. The arguments are:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
dft\_ot\_functional *otf & Functional to be used.\\
REAL rho & Bulk density.\\
\end{longtable}
This function returns the value of $dE/d\rho$ (REAL).

\subsection{dft\_ot\_bulk\_density() -- Calculate bulk liquid density when pressure is zero}

Calculate equilibrium density for uniform bulk with no pressure applied. In general, the equilibrium density is obtained by solving:\\
$$ P = (dE/d\rho)(\rho_0)\times \rho_0 - bulk\_energy(\rho_0)$$
For the Orsay-Trento functional with zero pressure, the solution is analytical but we use the general routine here. This function takes only one argument that describes the functional (dft\_ot\_functional *). The return value is the bulk liquid density when $P = 0$ (REAL).

\subsection{dft\_ot\_bulk\_chempot() -- Chemical potential of uniform bulk liquid}

Calculate the chemical potential of uniform bulk liquid at zero pressure. If this quantity is subtracted from the external potential then the imaginary time iterations converge to a solution with the equilibrium density at the simulation cell edges. This means that no rescaling during imaginary iterations is needed. This function takes only one argument that describes the functional (dft\_ot\_functional *). The return value is the chemical potential at bulk density ($P = 0$; REAL). Note that with moving background (i.e., non-zero kx, ky, kz for the complex wave function grid), additional term must be included in the chemical potential ($\mu_0$):
$$\mu = \mu_0 + \frac{\hbar^2}{2m}\left(kx^2 + ky^2 + kz^2\right)$$
where $\mu$ can be used in, e.g., imaginary time iterations.
% TODO: Rotation has something similar!

\subsection{dft\_ot\_bulk\_chempot2() -- Chemical potential of uniform bulk liquid}

Calculate the chemical potential of uniform bulk liquid at zero pressure. If this quantity is subtracted from the external potential then the imaginary time iterations converge to a solution with the equilibrium density at the simulation cell edges. This means that no rescaling during imaginary iterations is needed. This function takes one argument that describes the functional (dft\_ot\_functional *). The return value is the chemical potential at bulk density specified by dft\_ot\_functional structure member rho0 (REAL). With moving background, see the note in dft\_ot\_bulk\_chempot().

\subsection{dft\_ot\_bulk\_chempot3() -- Chemical potential of uniform bulk liquid}

Calculate the chemical potential of uniform bulk liquid at zero pressure. If this quantity is subtracted from the external potential then the imaginary time iterations converge to a solution with the equilibrium density at the simulation cell edges. This means that no rescaling during imaginary iterations is needed. This function takes two arguments that describe the functional (dft\_ot\_functional *) and the density where the chemical potential is sought (REAL). The return value is the chemical potential (REAL) at bulk density specified by the second argument. With moving background, see the note in dft\_ot\_bulk\_chempot().

\subsection{dft\_ot\_bulk\_pressure() -- Pressure of uniform bulk liquid}

Calculate the pressure of uniform bulk at a given density. This function takes two arguments that describe the functional (dft\_ot\_functional *) and the density where the pressure is sought (REAL). This function returns the external pressure (REAL) corresponding to the given density (2nd argument).

\subsection{dft\_ot\_bulk\_dPdRho() -- Evaluate $dP/d\rho$ for uniform bulk liquid}

Calculate the derivative of pressure with respect to density for uniform bulk liquid. This function takes two arguments that describe the functional (dft\_ot\_functional *) and the density where the derivative is sought (REAL). The function returns ($dP/d\rho$; REAL) evaluated at the given density (2nd argument).

\subsection{dft\_ot\_bulk\_density\_pressurized() -- Equilibrium density for uniform bulk liquid under pressure}

Calculate the equilibrium density for pressurized uniform bulk. The density is obtained iteratively by solving:
$$P = (dE/d\rho)(\rho_0)\times\rho_0 - bulk\_energy(\rho_0)$$
This function takes two arguments that describe the functional (dft\_ot\_functional *) and the pressure where the equilibrium density is sought (REAL). The function returns equilibrium bulk density at given pressure (REAL).

\subsection{dft\_ot\_bulk\_compressibility() -- Isothermal compressibility}

Calculate isothermal compressibility of uniform bulk liquid:
$$\kappa = \frac{1}{\rho} \frac{d\rho}{dP} = \frac{1}{\rho dP/d\rho}$$
which is evaluated at given $\rho$. This function takes two arguments that describe the functional (dft\_ot\_functional *) and the density where the isothermal compressibility is sought (REAL). The function returns isothermal compressibility at given density (REAL).

\subsection{dft\_ot\_bulk\_sound\_speed() -- Speed of sound}

Calculate speed of sound ($c$) in uniform bulk liquid:
$$ c = \frac{1}{\sqrt{m \kappa \rho}}$$
which is evaluated at given $\rho$. Here $\kappa$ is the isothermal compressibility, $m$ is the mass of $^4$He atom, and $\rho$ is the liquid density. This function takes two arguments that describe the functional (dft\_ot\_functional *) and the density where the speed of (first) sound is to be computed (REAL). The function returns speed of sound at given density (REAL).

\subsection{dft\_ot\_dispersion() -- Dispersion relation of bulk liquid}

Calculate the bulk liquid dispersion relation ($\omega$ vs. $k$). Uses numerical solution for the specified dft\_ot\_functional. This function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
wf *wf & Wave function to be used for the operation.\\
dft\_ot\_functional *otf & Functional pointer.\\
REAL ts & Time step to be used in a.u.\\
REAL k & Requested wavenumber in a.u.\\
REAL amp & Plane wave amplitude relative to bulk density (should be small; e.g., 10$^{-3}$).\\
char pred & 1 = Use predict-correct for propagation, 0 = no predict-correct.\\
char dir & Direction for the plane wave excitation (0 = X, 1 = Y, 2 = Z).\\
\end{longtable}
\noindent
This function returns the energy (i.e., $\omega$ in a.u.). To convert $k$ from a.u. to \AA{}$^{-1}$ and $\omega$ to Kelvin, use: k = k / GRID\_AUTOANG and omega = (omega / GRID\_AUTOS) * GRID\_HZTOCM1 * 1.439. The last factor is conversion from cm$^{-1}$ to Kelvin.

\subsection{dft\_ot\_bulk\_dispersion() -- Dispersion relation of bulk liquid (semi-analytic)}

Calculate bulk dispersion relation ($\omega$ vs. $k$) using semi-analytic solution (specific to Orsay-Trento). This function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
dft\_ot\_functional *otf & Functional pointer.\\
REAL *k & Wave vector. On output, contains the actual value of $k$ used for computing $\omega$.\\
REAL rho0 & Bulk density to be used.\\
\end{longtable}
\noindent
This function returns energy (i.e., $\omega$ in a.u.). To convert $k$ from a.u. to \AA{}$^{-1}$ and $\omega$ to Kelvin, use: k = k / GRID\_AUTOANG and omega = (omega / GRID\_AUTOS) * GRID\_HZTOCM1 * 1.439. The last factor is conversion from cm$^{-1}$ to Kelvin.

\subsection{dft\_ot\_bulk\_istatic() -- Static structure factor of bulk liquid}

Calculation of the static structure factor $\chi(q)$. This function takes two arguments where the first argument specifies the functional (dft\_ot\_functional *) and the second the wave vector $k$ where the quantity is evaluated at (REAL *). This function returns $-\frac{1}{\chi(q)}$ (REAL).

\subsection{dft\_ot\_bulk\_surface\_tension() -- Calculate (free) surface tension}

Calculate surface tension for flat surface. It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
wf *gwf & Wave function.\\
dft\_ot\_functional *otf & Functional structure.\\
REAL ts & Time step for propagation.\\
REAL width & Width of the slab used for making the surfaces.\\
\end{longtable}
\noindent
Returns surface tension (REAL). Warning: This routine seems out of date and may not work (TODO).

\section{Spectroscopy related routines}

These routines are related to computation of optical absorption/emission spectra of atoms or molecules solvated in liquids. Note that these routines are not currently very well tested as the code has been rewritten many times...

\subsection{dft\_spectrum() -- Compute spectrum by Andersson expression}

Evaluate absorption/emission spectrum using the Andersson expression. No zero-point correction for the impurity. This method does not require any dynamics to be run. The arguments are as follows:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
dft\_ot\_functional *otf & Functional pointer.\\
rgrid *density & Current liquid density.\\
REAL tstep & Time step for constructing the time correlation function (in fs). Typically around 1 fs.\\
REAL endtime & End time in constructing the time correlation function in fs). Typically less than 10,000 fs.\\
char finalave & Averaging of the final state potential: 0 = no averaging, 1 = average XY, 2 = average YZ, 3 = average XZ, 4 = average XYZ.\\
char *finalx & Final state potential along the X axis (file name).\\
char *finaly & Final state potential along the Y axis (file name).\\
char finalz & Final state potential along the Z axis (file name).\\
char initialave & Averaging of the initial state potential: 0 = no averaging, 1 = average XY, 2 = average YZ, 3 = average XZ, 4 = average XYZ.\\
char *initialx & Initial state potential along the X axis (file name).\\
char *initialy & Initial state potential along the Y axis (file name).\\
char *initialz & Initial state potential along the Z axis (file name).\\
\end{longtable}
\noindent
Returns pointer to the spectrum (cgrid *; one-dimensional data). Note that this is statically allocated and overwritten by a subsequent call to this routine. The spectrum will start from smaller to larger frequencies. The spacing between the points is included in cm-1.

\subsection{dft\_spectrum\_zp() -- Compute spectrum by Andersson expression with zero-point}

Evaluate absorption/emission spectrum using the Andersson expression. Zero-point correction for the impurity included. This function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
dft\_ot\_functional *otf & Functional pointer.\\
rgrid *density & Current liquid density.\\
rgrid *imdensity & Current impurity zero-point density.\\
REAL tstep & Time step for constructing the time correlation function (in fs). Typically around 1 fs.\\
REAL endtime & End time in constructing the time correlation function (in fs). Typically less than 10,000 fs.\\
char upperave & Averaging of the upper state potential: 0 = no averaging, 1 = average XY, 2 = average YZ, 3 = average XZ, 4 = average XYZ.\\
char *upperx & Upper state potential along the X axis (file name).\\
char *uppery & Upper state potential along the Y axis (file name).\\
char *upperz & Upper state potential along the Z axis (file name).\\
char lowerave & Averaging of the lower state potential: 0 = no averaging, 1 = average XY, 2 = average YZ, 3 = average XZ, 4 = average XYZ.\\
char *lowerx & Lower state potential along the X axis (file name).\\
char *lowery & Lower state potential along the Y axis (file name).\\
char *lowerz & Lower state potential along the Z axis (file name).\\
\end{longtable}
\noindent
This function returns pointer to the spectrum (cgrid *). Note that this is statically allocated and overwritten by a subsequent call to this routine. The spectrum will start from smaller to larger frequencies. The spacing between the points is included in cm-1.

\subsection{dft\_spectrum\_init() -- Initialize time-correlation function calculation}

The dft\_spectrum\_* routines evaluate the dynamic lineshape according to Chem. Phys. Lett. 396, 155 (2004) but see also J. Chem. Phys. 141, 014107 (2014) and references there in). The dynamics should be run on average potential of gnd and excited states, which is returned by the init routine (init or init2). The procedure of calculation is:
\begin{enumerate}
\item Initialize the difference potential: dft\_spectrum\_init() (or init2).
\item During the trajectory, call function: dft\_spectrum\_collect() to record the time dependent difference energy (difference potential convoluted with the time dependent liquid density).
\item At the end, call the following function to evaluate the spectrum: dft\_spectrum\_evaluate() to evaluate the lineshape.
\end{enumerate}

This routine initializes the data collection portion of the calculation. It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
dft\_ot\_functional *otf & Functional pointer.\\
rgrid *idensity & Impurity zero-point density for averaging (NULL if not used).\\
INT nt & Maximum number of time steps to be collected.\\
INT zerofill & How many zeros to fill in before doing FFT to get the spectrum.\\
char upperave & Averaging of the upper state potential: 0 = no averaging, 1 = average XY, 2 = average YZ, 3 = average XZ, 4 = average XYZ.\\
char *upperx & Upper state potential along the X axis (file name).\\
char *uppery & Upper state potential along the Y axis (file name).\\
char *upperz & Upper state potential along the Z axis (file name).\\
char lowerave & Averaging of the lower state potential: 0 = no averaging, 1 = average XY, 2 = average YZ, 3 = average XZ, 4 = average XYZ.\\
char *lowerx & Lower state potential along the X axis (file name).\\
char *lowery & Lower state potential along the Y axis (file name).\\
char *lowerz & Lower state potential along the Z axis (file name).\\
\end{longtable}
\noindent
This function returns the difference potential for dynamics (rgrid *).

\subsection{dft\_spectrum\_init2() -- Initialize time-correlation function calculation}

This function is exactly like dft\_spectrum\_init() but provides direct grid input for the potentials (rather than file names). It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
dft\_ot\_functional *otf & Functional pointer.\\
INT nt & Maximum number of time steps to be collected.\\
INT zerofill & How many zeros to fill in before doing FFT to calculate the spectrum.\\
rgrid *upper & Upper state potential grid.\\
rgrid *lower & Lower state potential grid.\\
\end{longtable}
\noindent
This function returns the difference potential for dynamics (rgrid *).

\subsection{dft\_spectrum\_collect\_user() -- Collect data point for time correlation function (user)}

Collect the energy difference data (calculated by external user routine). This function takes one argument, which specifies the energy difference value (REAL). It does not return any value.

\subsection{dft\_spectrum\_collect() -- Collect data point for time correlation function}

Collect the energy difference data during simulation. This function does not return any value and takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
dft\_ot\_functional *otf & Functional pointer.\\ 
wf *gwf & The current wave function (used for calculating the liquid density).\\
\end{longtable}

\subsection{dft\_spectrum\_evaluate() -- Compute spectrum from time correlation function}

After collecting the data points for the time correlation function, evaluate the spectrum itself (FFT). This takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
REAL tstep & Time step length at which the energy difference data was collected (in fs; usually the simulation time step).\\
REAL tc & Exponential decay time constant for time correlation function (in fs). Note since the true many-body wave function is not available, the decay must be introduced phenomenologically.\\
\end{longtable}
\noindent
This function returns a pointer to the calculated spectrum (grid *; 1-D grid). The X-axis in the spectrum is given in cm$^{-1}$.

\section{Common functions}

\subsection{dft\_common\_lennard\_jones() -- Lennard-Jones function}

Evaluate Lennard-Jones potential function that can be used with rgrid\_map() routines. Note that the L-J potential returns zero when $r < h$. The arguments are:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *arg & Pointer to dft\_common\_lj structure. This structure specifies the potential parameters.\\
REAL x & $x$-coordinate.\\
REAL y & $y$-coordinate.\\
REAL z & $z$-coordinate.\\
\end{longtable}
\noindent 
The potential parameters are passed in arg as ot\_common\_lj data type). This structure is defined as:
\begin{verbatim}
typedef struct lj_struct {
  REAL h;       /* Short range cutoff distance */
  REAL sigma;   /* Parameter sigma for Lennard-Jones */
  REAL epsilon; /* Parameter epsilon for Lennard-Jones */
  REAL cval;    /* Constant value when r < h */
} dft_common_lj;
\end{verbatim}
This function returns the Lennard-Jones potential at $(x,y,z)$ (REAL).

\subsection{dft\_common\_lennard\_jones\_1d() -- Lennard-Jones function (1-D)}

Effective 1-D Lennard-Jones potential function that can be used with rgrid\_map() routines. Note that the L-J potential returns zero when $r < h$. The arguments are:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *arg & Pointer to dft\_common\_lj structure. This structure specifies the potential parameters.\\
REAL x & $x$-coordinate (= 0).\\
REAL y & $y$-coordinate (= 0).\\
REAL z & $z$-coordinate. This is 1-D, only this varies.\\
\end{longtable}
\noindent 
The potential parameters are passed in arg as ot\_common\_lj data type). For description of this structure, see dft\_common\_lennard\_jones\_1d(). This function returns the Lennard-Jones potential at $(0,0,z)$ (REAL). This function is only used in 1-D implementation of Orsay-Trento functional.

\subsection{dft\_common\_lennard\_jones\_smooth() -- Lennard-Jones function with smoothly decaying core}

Calculate Lennard-Jones potential with smoothed core to be used with rgrid\_map() routines. The parameters and return value are identical to dft\_common\_lennard\_jones() but the core is handled differently ($r < h$). In this region the function decays smoothly as $(r/h)^4$ rather than cuts off abruptly. The return value is the Lennard-Jones potential value at $(x,y,z)$ (REAL).

\subsection{dft\_common\_spherical\_avg() -- Spherical average function}

Calculates spherical average function to be used with rgrid\_map() routines. The sphere radius is passed in arg (see below). The arguments to this function are:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *arg & Pointer to the radius of the sphere, which is of REAL type (REAL *).\\
REAL x & $x$-coordinate.\\
REAL y & $y$-coordinate.\\
REAL z & $z$-coordinate.\\
\end{longtable}
\noindent
This function returns the value of the spherical average function at $(x, y, z)$ (REAL).

\subsection{dft\_common\_spherical\_avg\_1d() -- Spherical average function (1-D)}

Calculates 1-D spherical average function to be used with rgrid\_map() routines. The sphere radius is passed in arg (see below). The arguments to this function are:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *arg & Pointer to the radius of the sphere, which is of REAL type (REAL *).\\
REAL x & $x$-coordinate (= 0).\\
REAL y & $y$-coordinate (= 0).\\
REAL z & $z$-coordinate.\\
\end{longtable}
\noindent
This function returns the value of the spherical average function at $(0, 0, z)$ (REAL). This function is used with 1-D implementation of Orsay-Trento.

\subsection{dft\_common\_spherical\_avg\_k() -- Spherical average function in momentum space}

Calculates spherical average function in momentum space to be used with rgrid\_map() routines. The sphere radius is passed in arg (see below). The arguments to this function are:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *arg & Pointer to the radius of the sphere, which is of REAL type (REAL *).\\
REAL kx & $kx$-coordinate.\\
REAL ky & $ky$-coordinate.\\
REAL kz & $kz$-coordinate.\\
\end{longtable}
\noindent
This function returns the value of the spherical average function at $(kx, ky, kz)$ (REAL).

\subsection{dft\_common\_gaussian() -- Gaussian function}

Evaluate Gaussian function to be used with rgrid\_map() functions. The Gaussian is centered at (0,0,0) and its width is given in arg (see below). The arguments to this function are:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *arg & Inverse width of the Gaussian function (REAL *).\\
REAL x & $x$-coordinate.\\
REAL y & $y$-coordinate.\\
REAL z & $z$-coordinate.\\
\end{longtable}
\noindent
This function returns the value of the value of the Gaussian function at $(x, y, z)$ (REAL).

\subsection{dft\_common\_gaussian\_1d() -- Gaussian function (1-D)}

Evaluate 1-D Gaussian function to be used with rgrid\_map() functions. The Gaussian is centered at (0,0,0) and its width is given in arg (see below). The arguments to this function are:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *arg & Inverse width of the Gaussian function (REAL *).\\
REAL x & $x$-coordinate (= 0).\\
REAL y & $y$-coordinate (= 0).\\
REAL z & $z$-coordinate.\\
\end{longtable}
\noindent
This function returns the value of the value of the Gaussian function at $(x, y, z)$ (REAL). This function is used for 1-D implementation of Orsay-Trento functional.

\subsection{dft\_common\_cgaussian() -- Gaussian function (complex)}

Evaluate Gaussian function to be used with cgrid\_map() functions. The Gaussian is centered at (0,0,0) and its width is given in arg (see below). The arguments to this function are:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *arg & Inverse width of the Gaussian function (REAL *).\\
REAL x & $x$-coordinate.\\
REAL y & $y$-coordinate.\\
REAL z & $z$-coordinate.\\
\end{longtable}
\noindent
This function returns the value of the value of the Gaussian function at $(x, y, z)$ (REAL complex).

\subsection{dft\_common\_lwl3() -- Thermal wavelength}

Given mass (1st argument; REAL) and temperature (2nd argument; REAL), return thermal wavelength for the particle (REAL):
$$\lambda = \left(\frac{2\pi\hbar^2}{m k_B T}\right)^3$$

\subsection{dft\_common\_g() -- Evaluate polylogarithm}

Evaluate polylog $g_s(z)$ with $z$ as the first argument (REAL) and $s$ as the second (REAL). The return value is the polylogarithm (REAL).

\subsection{dft\_common\_fit\_z() -- Invert polylogarithm $g_{3/2}$}

Invert polylogarithm function $g_{3/2}$ (i.e., the value of the polylogarithm is known but not the argument to it). This function takes one argument that specifies the point where to invert the function (REAL). The polylog argument value is returned (REAL).

\subsection{dft\_common\_classical\_idealgas\_dEdRho() -- $dE/d\rho$ for classical ideal gas}

Calculate Free energy / volume derivative with respect to density (rho) for classical ideal gas. This function takes one argument (REAL) that specifies the value of density where the derivative is to be evaluated (REAL).

\subsection{dft\_common\_classical\_idealgas\_energy() -- Energy of classical ideal gas}

Calculate the energy for classical ideal gas ($NVT$). This function takes two arguments that specify the value of density and pointer to structure dft\_ot\_functional (for temperature and mass). The function returns the energy (REAL).

\subsection{dft\_common\_bose\_idealgas\_energy() -- Energy of Bose ideal gas}

Calculate the energy for Bose ideal gas ($NVT$). This function takes two arguments that specify the value of density and pointer to structure dft\_ot\_functional (for temperature and mass). The function returns the energy (REAL).

\subsection{dft\_common\_bose\_idealgas\_dEdRho() -- $dE/d\rho$ for Bose ideal gas}

Calculate Free energy / volume derivative with respect to density (rho) for Bose ideal gas. This function takes one argument (REAL) that specifies the value of density where the derivative is to be evaluated (REAL).

\subsection{dft\_common\_read\_pot() -- Read pair-potential data from disk}

This function reads equidistant pair-potential data from a file. It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
char *file & File name for the potential.\\
dft\_extpot *pot & Where to store the potential.\\
\end{longtable}
\noindent
This function returns no value. The dft\_extpot structure is defined as:
\begin{verbatim}
typedef struct extpot {
  REAL points[DFT_MAX_POTENTIAL_POINTS];/* Array holding potential energy values */
  REAL begin;                           /* Starting distance for potential */
  INT length;                           /* Number of points in the potential array */
  REAL step;                            /* Step length between potential points */
} dft_extpot;
\end{verbatim}
This function does not return any value.

\subsection{dft\_common\_extpot() -- Map function based on pair-potential data}

This function returns values based on given extpot\_set structure (potentials along $x$, $y$, and $z$) and can be used with grid\_map() routines. The arguments are:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *arg & Potential set (dft\_extpot\_set *).\\
REAL x & $x$-coordinate.\\
REAL y & $y$-coordinate.\\
REAL z & $z$-coordinate.\\
\end{longtable}
\noindent
The extpot\_set structure is defined as:
\begin{verbatim}
typedef struct extpot_set {
  dft_extpot *x;                    /* Potential along x-axis */
  dft_extpot *y;                    /* Potential along y-axis */
  dft_extpot *z;                    /* Potential along z-axis */
  char average;                     /* Averaging: 0 = no averaging */
                                    /* 1 = average in xy-plane */
                                    /* 2 = average in yz-plane */
                                    /* 3 = average in xz-plane */
                                    /* 4 = spherical average */
  REAL theta0;                      /* orientation of the potential */
  REAL phi0;                        /* (theta0, phi0) (rotation) */
  REAL x0, y0, z0;                  /* Origin for the potential */                                                               
} dft_extpot_set;
\end{verbatim}
The function returns the potential value at $(x,y,z)$ (REAL).

\subsection{dft\_common\_potential\_map\_rotate\_shift() -- Map potential with rotation and shifting}

Map a potential given by ascii files into a grid. The arguments are:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
char average & 0 = no averaging, 1 = average XY, 2 = average YZ, 3 = average XZ, 4 = average XYZ.\\
char *file\_x & Potential along $x$ axis (file name).\\
char *file\_y & Potential along $y$ axis (file name).\\
char *file\_z & Potential along $z$ axis (file name).\\
rgrid *potential & Output potential grid.\\
REAL theta0 & Rotation angle theta for potential.\\
REAL phi0   & Rotation angle phi for potential.\\
REAL x0    & Origin $x$.\\
REAL y0    & Origin $y$.\\
REAL z0    & Origin $z$.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{dft\_common\_potential\_smap\_rotate\_shift() -- Smooth map potential with rotation and shifting}

Same as dft\_common\_potential\_map\_rotate\_shift() but includes smoothing of the potential.

\subsection{dft\_common\_pot\_interpolate() -- Interpolated 3-D potential energy surface}

Produce interpolated 3-D potential energy surface from n 1-D cuts along $\phi = 0, \pi/n, ..., \pi$ directions (symmetric for $]\pi,2\pi[$). Requires cylindrical symmetry for the overall potential (i.e., linear molecule). All potentials must have the same range, steps, number of points. The arguments are as follows:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
INT n & Number of potentials along $n$ different angles.\\
char **files & Array of strings for file names containing the potentials.\\
rgrid *out & 3-D real grid containing the angular interpolated potential data.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{dft\_common\_pot\_spline() -- Spline interpolated 3-D potential energy surface}

Like dft\_common\_pot\_interpolate() but uses spline interpolation.

\subsection{dft\_common\_pot\_angularderiv() -- Angular derivative of potential (from files)}

Compute the (numerical) second derivative with respect to the angle of the potential.
This is done via second-order finite difference formula:
$$f''(i) = h^2 ( f(i-1) - 2f(i) + f(i+1) )$$
where $h = 2\pi / nx$. This function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
INT n & Number of potential files.\\
char **files & Array of file names that form the potential surface.\\
rgrid *out & Output grid containing angular derivatives.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{dft\_common\_pot\_average() -- Spherically averaged potential (from files)}

Produce spherically averaged 1-D potential energy surface from $n$ 1-D cuts along $\phi = 0, \pi/n, ..., \pi$ directions. Note that this is different from dft\_common\_pot\_interpolate() where you must give potentials for the whole $2\pi$. 
This routine requires cylindrical symmetry for the overall potential (i.e., linear molecule). All potentials must have the same range, steps, number of points. The arguments are as follows:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
INT n  & Number of potentials along $n$ different angles.\\
char **files & Array of strings for file names containing the potential file names.\\
rgrid *out & Real grid containing the angular interpolated potential grid.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{dft\_common\_planewave() -- Plane wave function}

Implement plane wave function that is suitable for grid\_map() functions. Here arg specifies the plane wave params according to dft\_plane\_wave structure. The function takes arguments as:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *arg & Plane wave parameters (dft\_plane\_wave *).\\
REAL x & $x$ coordinate.\\
REAL y & $y$ coordinate.\\
REAL z & $z$ coordinate.\\
\end{longtable}
\noindent
This function returns the plane wave function value at $(x, y, z)$ (REAL). The dft\_plane\_wave structure is defined as:
\begin{verbatim}
typedef struct {
  REAL kx, ky, kz;    /* Wave vectors along x, y, z */
  REAL a;             /* Relative amplitude */
                      /* Absolute amp = a * sqrt(rho) */
  REAL rho;           /* Background amplitude = sqrt(rho) */
                      /* (add this constant to plane wave) */
} dft_plane_wave;
\end{verbatim}

\subsection{dft\_common\_vortex\_x() -- Feynman-Onsager potential for vortex along $x$}

A potential function (Feynman-Onsager ansatz) that produces a vortex line profile along $x$ axis (no phase circulation). This can be used directly with rgrid\_map() functions. This function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *param & Atom (helium) mass (REAL *).\\
REAL x & $x$ coordinate.\\
REAL y & $y$ coordinate.\\
REAL z & $z$ coordinate.\\
\end{longtable}
\noindent
This function returns the potential value (REAL complex) at $(x, y, z)$. 

\subsection{dft\_common\_vortex\_y() -- Feynman-Onsager potential for vortex along $y$}

A potential function (Feynman-Onsager ansatz) that produces a vortex line profile along $y$ axis (no phase circulation). This can be used directly with rgrid\_map() functions. This function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *param & Atom (helium) mass (REAL *).\\
REAL x & $x$ coordinate.\\
REAL y & $y$ coordinate.\\
REAL z & $z$ coordinate.\\
\end{longtable}
\noindent
This function returns the potential value (REAL complex) at $(x, y, z)$. 

\subsection{dft\_common\_vortex\_z() -- Feynman-Onsager potential for vortex along $z$}

A potential function (Feynman-Onsager ansatz) that produces a vortex line profile along $z$ axis (no phase circulation). This can be used directly with rgrid\_map() functions. This function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *param & Atom (helium) mass (REAL *).\\
REAL x & $x$ coordinate.\\
REAL y & $y$ coordinate.\\
REAL z & $z$ coordinate.\\
\end{longtable}
\noindent
This function returns the potential value (REAL complex) at $(x, y, z)$. 

\section{Initial guess functions}

These functions are useful for generating various types of initial guesses for imaginary time propagation.

\subsection{dft\_initial\_vortex\_x\_n1() -- One quantum of vorticity about $x$ axis}

This can be used with grid\_wf\_map (or cgrid\_map() series of functions) to create suitable initial guess for a vortex line (one quantum) oriented along $x$ axis. This is useful for providing initial guess for imaginary time propagation that is sought to converge to such vortex line. This function takes three arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *na & This is not in use but is required by the map routines (can be set to NULL).\\
REAL x & $x$ coordinate.\\
REAL y & $y$ coordinate.\\
REAL z & $z$ coordinate.\\
\end{longtable}
\noindent
This function returns the initial guess (REAL complex) at $(x, y, z)$. This should be multiplied by $\sqrt{\rho_0}$ (square root of bulk density) in order to get bulk density far away. 

\subsection{dft\_initial\_vortex\_y\_n1() -- One quantum of vorticity about $y$ axis}

This can be used with grid\_wf\_map (or cgrid\_map() series of functions) to create suitable initial guess for a vortex line (one quantum) oriented along $y$ axis. This is useful for providing initial guess for imaginary time propagation that is sought to converge to such vortex line. This function takes three arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *na & This is not in use but is required by the map routines (can be set to NULL).\\
REAL x & $x$ coordinate.\\
REAL y & $y$ coordinate.\\
REAL z & $z$ coordinate.\\
\end{longtable}
\noindent
This function returns the initial guess (REAL complex) at $(x, y, z)$. This should be multiplied by $\sqrt{\rho_0}$ (square root of bulk density) in order to get bulk density far away. 

\subsection{dft\_initial\_vortex\_z\_n1() -- One quantum of vorticity about $z$ axis}

This can be used with grid\_wf\_map (or cgrid\_map() series of functions) to create suitable initial guess for a vortex line (one quantum) oriented along $z$ axis. This is useful for providing initial guess for imaginary time propagation that is sought to converge to such vortex line. This function takes three arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *na & This is not in use but is required by the map routines (can be set to NULL).\\
REAL x & $x$ coordinate.\\
REAL y & $y$ coordinate.\\
REAL z & $z$ coordinate.\\
\end{longtable}
\noindent
This function returns the initial guess (REAL complex) at $(x, y, z)$. This should be multiplied by $\sqrt{\rho_0}$ (square root of bulk density) in order to get bulk density far away. 

\subsection{dft\_initial\_vortex\_x\_n2() -- Two quanta of vorticity about $x$ axis}

This can be used with grid\_wf\_map (or cgrid\_map() series of functions) to create suitable initial guess for a vortex line (two quanta) oriented along $x$ axis. This is useful for providing initial guess for imaginary time propagation that is sought to converge to such vortex line. This function takes three arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *na & This is not in use but is required by the map routines (can be set to NULL).\\
REAL x & $x$ coordinate.\\
REAL y & $y$ coordinate.\\
REAL z & $z$ coordinate.\\
\end{longtable}
\noindent
This function returns the initial guess (REAL complex) at $(x, y, z)$. This should be multiplied by $\sqrt{\rho_0}$ (square root of bulk density) in order to get bulk density far away. 

\subsection{dft\_initial\_vortex\_y\_n2() -- Two quanta of vorticity about $y$ axis}

This can be used with grid\_wf\_map (or cgrid\_map() series of functions) to create suitable initial guess for a vortex line (two quanta) oriented along $y$ axis. This is useful for providing initial guess for imaginary time propagation that is sought to converge to such vortex line. This function takes three arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *na & This is not in use but is required by the map routines (can be set to NULL).\\
REAL x & $x$ coordinate.\\
REAL y & $y$ coordinate.\\
REAL z & $z$ coordinate.\\
\end{longtable}
\noindent
This function returns the initial guess (REAL complex) at $(x, y, z)$. This should be multiplied by $\sqrt{\rho_0}$ (square root of bulk density) in order to get bulk density far away. 

\subsection{dft\_initial\_vortex\_z\_n2() -- Two quanta of vorticity about $z$ axis}

This can be used with grid\_wf\_map (or cgrid\_map() series of functions) to create suitable initial guess for a vortex line (two quanta) oriented along $z$ axis. This is useful for providing initial guess for imaginary time propagation that is sought to converge to such vortex line. This function takes three arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *na & This is not in use but is required by the map routines (can be set to NULL).\\
REAL x & $x$ coordinate.\\
REAL y & $y$ coordinate.\\
REAL z & $z$ coordinate.\\
\end{longtable}
\noindent
This function returns the initial guess (REAL complex) at $(x, y, z)$. This should be multiplied by $\sqrt{\rho_0}$ (square root of bulk density) in order to get bulk density far away. 

\subsection{dft\_initial\_bubble() -- Initial configuration for bubble}

Initial guess for a bubble (can be used with cgrid\_map() etc.) with a Heaviside edge. This function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *prm & Bubble radius (REAL *).\\
REAL x & $x$ coordinate.\\
REAL y & $y$ coordinate.\\
REAL z & $z$ coordinate.\\
\end{longtable}
\noindent
This function returns function value at $(x, y, z)$. This value should be multiplied by $\sqrt{\rho_0}$ for bulk liquid.

\section{Calculation of viscous response}

Viscosity can be included in DFT by backtracking (Madelung transformation) the viscous response terms from Navier-Stokes equation. This is not a straight forward approach as it is not necessarily clear what should happen at gas - liquid interfaces.

\subsection{dft\_viscous\_potential() -- Add Navier-Stokes viscous potential}

Add viscous potential from Navier-Stokes (see J. Chem. Phys. 145, 044105 (2016)). This function takes the following parameters:
\begin{longtable}{p{.25\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
wf *gwf & Wave function.\\
dft\_ot\_functional *otf & Functional pointer.\\
REAL viscosity & Viscosity in atomic units ($\eta_0$).\\
REAL viscosity\_alpha & Exponent ($\alpha$) for scaling viscosity at interface ($> 0$).\\
\end{longtable}
\noindent
The viscosity is assumed to depend on the bulk density as:
$$\eta = \eta_0\left(\frac{\rho}{\rho_0}\right)^\alpha$$
This function does not return any value.

\chapter{Examples}

\subsection{Orsay-Trento: 1-D ``bubble"}

Implement a wall (1-D symmetry) in bulk superfluid helium. Move the wall for a short time and then follow the dynamics. This emits both bright and dark solitons around the wall.

\begin{verbatim}
/*
 * "One dimensional bubble" propagating in superfluid helium (propagating along Z).
 * 1-D version with X & Y coordinates integrated over in the non-linear
 * potential.
 *
 * All input in a.u. except the time step, which is fs.
 *
 */

/* Required system headers */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>

/* libgrid headers */
#include <grid/grid.h>
#include <grid/au.h>

/* libdft headers */
#include <dft/dft.h>
#include <dft/ot.h>

#define TS 1.0 /* Time step (fs) */
#define NZ (32768)  /* Length of the 1-D grid */
#define STEP 0.2    /* Step length for the grid */
#define IITER 200000 /* Number of warm-up imaginary time iterations */
#define SITER 250000 /* Stop liquid flow after this many iterations */
#define MAXITER 80000000  /* Maximum iterations */
#define NTH 2000          /* Output liquid density every NTH iterations */
#define VZ (2.0 / GRID_AUTOMPS)  /* Liquid velocity (m/s) */

#define PRESSURE (0.0 / GRID_AUTOBAR)  /* External pressure (bar) */
#define THREADS 16                     /* Use this many OpenMP threads */

/* Use Predict-correct for propagation? */
#define PC

/* Bubble parameters - exponential repulsion (approx. electron bubble) - RADD = 19.0 */
#define A0 (3.8003E5 / GRID_AUTOK)
#define A1 (1.6245 * GRID_AUTOANG)
#define A2 0.0
#define A3 0.0
#define A4 0.0
#define A5 0.0
#define RMIN 2.0
#define RADD 6.0

/* Initial guess for bubble radius (imag. time) */
#define BUBBLE_RADIUS (15.0 / GRID_AUTOANG)

/* Function generating the initial guess (1-d sphere) */
REAL complex bubble_init(void *prm, REAL x, REAL y, REAL z) {

  double *rho0 = (REAL *) prm;

  if(FABS(z) < BUBBLE_RADIUS) return 0.0;
  return SQRT(*rho0);
}

/* Round velocity to fit the simulation box */
REAL round_veloc(REAL veloc) {

  INT n;
  REAL v;

  n = (INT) (0.5 + (NZ * STEP * DFT_HELIUM_MASS * veloc) / (HBAR * 2.0 * M_PI));
  v = ((REAL) n) * HBAR * 2.0 * M_PI / (NZ * STEP * DFT_HELIUM_MASS);
  fprintf(stderr, "Requested velocity = %le m/s.\n", veloc * GRID_AUTOMPS);
  fprintf(stderr, "Nearest velocity compatible with PBC = %le m/s.\n", v * GRID_AUTOMPS);
  return v;
}

/* Given liquid velocity, calculate the momentum */
REAL momentum(REAL vz) {

  return DFT_HELIUM_MASS * vz / HBAR;
}

/* Potential producing the bubble (centered at origin, z = 0) */
REAL bubble(void *asd, REAL x, REAL y, REAL z) {

  REAL r, r2, r4, r6, r8, r10;

  r = FABS(z);
  r -= RADD;
  if(r < RMIN) r = RMIN;

  r2 = r * r;
  r4 = r2 * r2;
  r6 = r4 * r2;
  r8 = r6 * r2;
  r10 = r8 * r2;
  /* Exponential repulsion + dispersion series */
  return A0 * EXP(-A1 * r) - A2 / r4 - A3 / r6 - A4 / r8 - A5 / r10;
}

/* Main program - we start execution here */
int main(int argc, char **argv) {

  rgrid *density, *ext_pot; /* Real grids for density and external potential */
  cgrid *potential_store;   /* Complex grid holding potential */
  wf *gwf, *gwfp;           /* Wave function + predicted wave function */
  dft_ot_functional *otf;   /* Functional pointer to define DFT */
  INT iter;                 /* Iteration counter */
  REAL rho0, mu0, vz, kz;   /* liquid density, chemical potential, velocity, momentum */
  char buf[512];            /* Buffer for file name */
  REAL complex tstep;       /* Time step (complex) */
  grid_timer timer;         /* Timer structure to record execution time */

#ifdef USE_CUDA
  cuda_enable(1);           /* If cuda available, enable it */
#endif

  /* Initialize threads & use wisdom */
  grid_set_fftw_flags(1);    /* FFTW planning = FFTW_MEASURE */
  grid_threads_init(THREADS);/* Initialize OpenMP threads */
  grid_fft_read_wisdom(NULL);/* Use FFTW wisdom if available */

  /* Allocate wave functions: periodic boundaries and 2nd order FFT propagator */
  if(!(gwf = grid_wf_alloc(1, 1, NZ, STEP, DFT_HELIUM_MASS, WF_PERIODIC_BOUNDARY,
                           WF_2ND_ORDER_FFT, "gwf"))) {
    fprintf(stderr, "Cannot allocate gwf.\n");
    exit(1);
  }
  gwfp = grid_wf_clone(gwf, "gwfp"); /* Clone gwf to gwfp (same but new grid) */

  /* Moving background at velocity VZ */
  vz = round_veloc(VZ);
  printf("VZ = " FMT_R " m/s\n", vz * GRID_AUTOMPS);
  kz = momentum(VZ);
  /* Set the moving background momentum to wave functions */
  cgrid_set_momentum(gwf->grid, 0.0, 0.0, kz);
  cgrid_set_momentum(gwfp->grid, 0.0, 0.0, kz);

  /* Allocate OT functional (full Orsay-Trento) */
  if(!(otf = dft_ot_alloc(DFT_OT_PLAIN | DFT_OT_BACKFLOW | DFT_OT_KC, gwf,
                          DFT_MIN_SUBSTEPS, DFT_MAX_SUBSTEPS))) {
    fprintf(stderr, "Cannot allocate otf.\n");
    exit(1);
  }

  /* Bulk density at pressure PRESSURE */
  rho0 = dft_ot_bulk_density_pressurized(otf, PRESSURE);
  /* Chemical potential at pressure PRESSURE + hbar^2 kz * kz / (2 * mass) */
  /* So, mu0 = mu0 + moving background contribution */
  mu0 = dft_ot_bulk_chempot_pressurized(otf, PRESSURE) + (HBAR * HBAR / 
                                       (2.0 * gwf->mass)) * kz * kz;
  printf("mu0 = " FMT_R " K/atom, rho0 = " FMT_R " Angs^-3.\n", mu0 * GRID_AUTOK, 
         rho0 / (GRID_AUTOANG * GRID_AUTOANG * GRID_AUTOANG));

  /* Use the real grid in otf structure (otf->density) rather than allocate new grid */
  density = otf->density;
  /* Allocate space for potential grid */
  potential_store = cgrid_clone(gwf->grid, "Potential store");
  /* Allocate space for external potential */
  ext_pot = rgrid_clone(density, "ext_pot");

  /* set up external potential (function bubble) */
  rgrid_map(ext_pot, bubble, NULL);

  /* set up initial density */
  if(argc == 2) {
    /* Read starting point from checkpoint file */
    FILE *fp;
    if(!(fp = fopen(argv[1], "r"))) {
      fprintf(stderr, "Can't open checkpoint .grd file.\n");
      exit(1);
    }
    sscanf(argv[1], "bubble-" FMT_I ".grd", &iter);
    cgrid_read(gwf->grid, fp);
    fclose(fp);
    fprintf(stderr, "Check point from %s with iteration = " FMT_I "\n", argv[1], iter);
  } else {
    /* Bubble initial guess */
    cgrid_map(gwf->grid, bubble_init, &rho0);
    iter = 0;
  }

  /* Main loop over iterations */
  for ( ; iter < MAXITER; iter++) {

    /* Output every NTH iteration */
    if(!(iter % NTH)) {
      sprintf(buf, "bubble-" FMT_I, iter); /* construct file name */
      grid_wf_density(gwf, density);  /* get density from gwf */
      rgrid_write_grid(buf, density); /* write density to disk */
    }

    /* determine time step */
    if(iter < IITER) tstep = -I * TS; /* Imaginary time */
    else tstep = TS; /* Real time */

    /* AFter SITER's, stop the flow */
    if(iter > SITER) {
      /* Reset background velocity to zero */
      cgrid_set_momentum(gwf->grid, 0.0, 0.0, 0.0);
      cgrid_set_momentum(gwfp->grid, 0.0, 0.0, 0.0);
      /* Reset the chemical potential (remove moving background contribution) */
      mu0 = dft_ot_bulk_chempot_pressurized(otf, PRESSURE);
    }

    grid_timer_start(&timer); /* start iteration timer */
    cgrid_zero(potential_store);  /* clear potential */
    /* If PC is defined, use predict-correct */
    /* If not, use single stepping */
#ifdef PC
    /* predict-correct */
    /* Add O-T potential at current time */
    dft_ot_potential(otf, potential_store, gwf);
    /* Add external potential */
    grid_add_real_to_complex_re(potential_store, ext_pot);
     /* Add -chemical potential */ 
    cgrid_add(potential_store, -mu0);
     /* predict step */
    grid_wf_propagate_predict(gwf, gwfp, potential_store, tstep / GRID_AUTOFS);
    /* Get O-T potential at prediction point */
    dft_ot_potential(otf, potential_store, gwfp);
    /* Add external potential */
    grid_add_real_to_complex_re(potential_store, ext_pot);
    /* add -chemical potential */
    cgrid_add(potential_store, -mu0);    
    /* For correct step, use potential (current + future) / 2 */          
    cgrid_multiply(potential_store, 0.5);
    /* Take the correct step */
    grid_wf_propagate_correct(gwf, potential_store, tstep / GRID_AUTOFS); 
#else
    /* single stepping */
    /* Get O-T potential */
    dft_ot_potential(otf, potential_store, gwf);
    /* Add external potential */
    grid_add_real_to_complex_re(potential_store, ext_pot);
    /* Add -chemical potential */
    cgrid_add(potential_store, -mu0);
    /* Propagate */             
    grid_wf_propagate(gwf, potential_store, tstep / GRID_AUTOFS);  
#endif

    /* Report Wall time used for the current iteration */
    printf("Iteration " FMT_I " - Wall clock time = " FMT_R " seconds.\n", iter,
           grid_timer_wall_clock_time(&timer));
    /* After five iterations, write out FFTW wisdom */
    if(iter == 5) grid_fft_write_wisdom(NULL);
  }
  return 0;  /* The End */
}
\end{verbatim}

\end{document}
